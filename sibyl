#!/usr/bin/env python3
import sys
import signal
import json
import time
import numpy as np
import matplotlib.cm as cm
import argparse
import pyqtgraph as pg
import pyqtgraph.opengl as gl
import rat
import ROOT
from sibyl_cpp import *
from PyQt5 import *
from PyQt5.QtOpenGL import *
import _thread
from sibyl_python import *

pg.setConfigOptions(antialias=True)

''' -- Sibyl Event Viewer --> Central Widget
|------------------------------------------|
|Main|Crate|...|                           |
|------------------------------------------|
|         --         |     .^.^.^.^.       |
|        -  -        |    /         \      |
|         --         |   /    3D     \     |
| ------------------ |  /             \    |
| |                | |----------|----------|
| |________________| | Info     |_    Hist |
|         --         | Panel    | |__  Q/T |
|        -  -        |          |    |_    |
|         --         |          |      |__ |
|------------------------------------------|

Central Widget is contained in the MainWindow as:
|-----------------------------------------|
| Menu Bar                                |
|-----------------------------------------|
|                Toolbars                 |
|  |-----------------------------------|  |
|  |           Dock Widgets            |  |
|  |  |-----------------------------|  |  |
|  |  |                             |  |  |
|  |  |                             |  |  |
|  |  |       Central Widget        |  |  |
|  |  |                             |  |  |
|  |  |                             |  |  |
|  |  |-----------------------------|  |  |
|  |                                   |  |
|  |-----------------------------------|  |
|                                         |
|-----------------------------------------|
| Status Bar                              |
|-----------------------------------------|
'''

#class MainWindow(QtGui.QWidget):
class MainWindow(QtGui.QMainWindow):
    '''
    Order of operations:
    1. Create the main window
    2. Create grid layout
    3. Open the ratroot file to get information and store event info
    '''
    App = None
    plot = None
    parameters = {}
    config = {}

    ''' Set by rat '''
    entries = 999

    def __init__(self, args, app=None):
        self.args = args
        self._default_parameters()
        # Icon
        self.fname = self.args.ratfile
        if self.App is None:
            if app is not None:
                self.App = app
            else:
                self.App = QtGui.QApplication([])
        super(MainWindow,self).__init__()
        self.trayIcon = SibylTrayIcon()
        self.trayIcon.show()
        #self.App.setWindowIcon(QtGui.QIcon('wmlogo.png'))
        #self.setWindowIcon(QtGui.QIcon('wmlogo.png'))
        self.beginRat()
        self.buildLayout()

    def _default_parameters(self):
        '''
        The parameters dictionary is used to allow widgets
        to share and update information. Must be careful to
        make sure multiple modules dont set the same parameter.
        '''
        self.parameters["name"] = "Sibyl"
        self.parameters["autoRange"] = True
        self.parameters["colorMask"] = 'charge'
        self.parameters["histXMax"] = 1
        self.parameters["histYMax"] = 1
        self.parameters["colorMap"] = cm.cividis
        self.parameters["colorMap"] = cm.viridis



    def keyPressEvent(self, ev):
        if ( (ev.modifiers() & QtCore.Qt.ControlModifier) and
             (ev.key() == ord('W')) ):
            self.close()

    def buildLayout(self):
        formGroupBox = QtGui.QGroupBox()
        formLayout = QtGui.QFormLayout()
        # Main layout = QtGui.QGridLayout()
        self.layout = QtGui.QGridLayout()
        # Events
        self.total_events_line = QtGui.QLineEdit("0")
        self.total_events_line.setReadOnly(True)
        self.total_events_line.setText(str(self.entries))
        formLayout.addRow(QtGui.QLabel("Total Events"), self.total_events_line)
        ## Event switcher buttons
        left_button = QtGui.QPushButton("<")
        left_button.clicked.connect(self.leftEvent)
        right_button = QtGui.QPushButton(">")
        right_button.clicked.connect(self.rightEvent)
        self.event = QtGui.QLineEdit("0")
        self.event.textChanged.connect(self.newEvent)
        self.hboxchooser = QtGui.QHBoxLayout()
        self.hboxchooser.addWidget(left_button)
        self.hboxchooser.addWidget(right_button)
        self.hboxchooser.addWidget(self.event)
        formLayout.addRow(self.hboxchooser)

        ## Choose charge mode
        chargeTime_button = QtGui.QPushButton("Q/T Toggle")
        chargeTime_button.clicked.connect(self.toggleColorMode)
        self.hboxchooser.addWidget(chargeTime_button)

        ## Fit current event
        fit_button = QtGui.QPushButton()
        fit_button.clicked.connect(self.performFit)
        fit_button.setIcon(QtGui.QIcon('assets/bonsai.png'))
        fit_button.setToolTip('Bonsai!')
        self.hboxchooser.addWidget(fit_button)

        ## Put form together
        formGroupBox.setLayout(formLayout)
        ## Top bar:
        self.layout.addWidget(formGroupBox,0,0,1,16)
        ## EV Info panel
        #self.pFig = Figure()
        #self.pAxis = self.pFig.add_subplot(111)
        #self.figCanvas = FigureCanvas(self.pFig)
        self.figCanvas = SibylHistogram(self.App, self)
        #evinfoGroupBox = QtGui.QGroupBox()
        self.layout.addWidget(self.figCanvas,6,12,3,4)

        # If we want to pop-out widgets instead of putting them
        # into a layout, simply use widget.show() i.e.
        # self.figCanvas.show()

        #layout.addWidget(evinfoGroupBox,6,12,3,4)

        ## Now the 3D graph
        self.plot3DView = gl.GLScatterPlotItem(pxMode=False)
        self.plotTracks = gl.GLLinePlotItem(mode='lines', color=(1,0,0,0.1))
        #self.plotFlatMap = gl.GLScatterPlotItem(pxMode=False, size=300)
        self.plotFlatMap = SibylWatchmanFlat()
        self.newEvent()
        self.glWin = Sibyl3DViewer(self.plot3DView, self.plotTracks, self.App)
        self.flatMapWindow = Sibyl2DViewer(self.plotFlatMap, self.App)
        #self.layout.addWidget(self.glWin,1,0,4,1)
        #self.flatMapWindow.addItem(self.plotFlatMap)
        self.layout.addWidget(self.flatMapWindow,1,0,8,8)
        self.layout.addWidget(self.glWin,1,8,5,8)

        # Fix the column and row stretch
        for r in range(9):
            self.layout.setRowStretch(r, 1)
        for c in range(16):
            self.layout.setColumnStretch(c, 1)
        mainWidget = QtGui.QWidget()
        mainWidget.setLayout(self.layout)
        self.setCentralWidget(mainWidget)
        self.show()

    def _toolbar_setup(self):
        self.toolbar = QtGui.QToolBar()
        # Quit Button
        quitButton = QtGui.QPushButton("X")

    def performFit(self):
        print('Bonsai!')

    def toggleColorMode(self):
        if self.parameters['colorMask'] == 'charge':
            self.parameters['colorMask'] = 'time'
        else:
            self.parameters['colorMask'] = 'charge'
        self.drawEvent()

    def leftEvent(self):
        min_event = 0
        cur_event = int(self.event.text())
        if cur_event > (min_event):
            cur_event -= 1
        self.event.setText(str(cur_event))

    def rightEvent(self):
        max_event = int(self.total_events_line.text())
        cur_event = int(self.event.text())
        if cur_event < (max_event-1):
            cur_event += 1
        self.event.setText(str(cur_event))

    def updateEvent(self):
        self.readRat()
        if self.args.tracking:
            self.readRatTracking()
        self.drawEvent()

    def newEvent(self):
        min_event, max_event = 0, int(self.total_events_line.text())
        try:
            cur_event = int(self.event.text())
        except ValueError:
            self.event.setText("0")
            cur_event = int(self.event.text())
        if (cur_event >= min_event) and (cur_event < max_event):
            self.updateEvent()
        else:
            self.event.setText("0")

    ## Rat, moveme to rat class
    def beginRat(self):
        self.cobra = snake()
        self.cobra.openFile(self.fname)
        self.posArray = np.array(self.cobra.getXYZ()).T
        self.entries = self.cobra.getEntries()
    
    # Helper function, root TMap to python dict, this one for strings
    def _tmap_to_dict(self,tmap):
        tdict = {}
        for k in tmap:
            tdict[str(k)] = str(tmap.GetValue(k))
        return tdict

    def readRat(self):
        event =int(self.event.text())
        self.cobra.getEvent(event)
        self.CHARGE, self.TIME = self.cobra.getHitInfo()
        self.plWeights = np.zeros(len(self.CHARGE)) + 100
        self.plWeights[self.CHARGE>-99] = 300


    def readRatTracking(self):
        # Clear last event
        event = int(self.event.text())
        mc = self.ds.GetEvent(event).GetMC()
        nTracks = mc.GetMCTrackCount()
        # Colors based on: ID and Process if optical
        # Yellow: electron
        clr_electron = (1, 1, 0, 1.0)
        # Green: Gamma
        clr_gamma = (0, 1, 0, 1.0)
        # Cherenkov: Blue
        clr_cerenkov = (0, 0.5, 1.0, 0.1)
        # Scintillation: Pink
        clr_scint = (1, 0, 0.5, 0.1)
        clr_reim = (0, 0, 1, 0.1)
        clr_dict = {'e-':clr_electron,
                    'gamma':clr_gamma,
                    'Cerenkov':clr_cerenkov,
                    'Scintillation':clr_scint,
                    'Reemission':clr_scint}
        clr_other = (0.7, 0.7, 0.8, 0.1)
        clr_list = []
        nlist = []
        for trk in range(nTracks):
            track = mc.GetMCTrack(trk)
            name = track.GetParticleName()
            if name == 'opticalphoton':
                name = track.GetMCTrackStep(0).GetProcess()
            nSteps = track.GetMCTrackStepCount()
            # A path consists of steps-1 segments:
            path = []
            for stp in range(nSteps):
                step = track.GetMCTrackStep(stp)
                tv = step.GetEndpoint()
                x, y, z = tv.X(), tv.Y(), tv.Z()
                path.append( (x, y, z) )
            x, y, z = np.array(path).T
            xx = np.roll(np.repeat(x, 2), -1)[:-2]
            yy = np.roll(np.repeat(y, 2), -1)[:-2]
            zz = np.roll(np.repeat(z, 2), -1)[:-2]
            jj = np.array([xx, yy, zz]).T
            if name in clr_dict:
                color_choice = clr_dict[name]
            else:
                color_choice = clr_other
            clr_list.append( np.array([color_choice for i in range(len(jj))]) )
            nlist.append(jj)
        if len(nlist) > 0:
            tarray = np.concatenate(nlist)
            carray = np.concatenate(clr_list)
            self.plotTracks.pos = tarray
            self.plotTracks.color = carray

    def addPMT(self, pmtpos):
        self.posArray = np.append(self.posArray, np.array([pmtpos]), axis=0)

    def drawEvent(self):
        self.colorize()
        ## 3D Viewport
        if self.plot3DView is None:
            self.plot3DView = gl.GLScatterPlotItem(pos=self.posArray,
                    color=self.colorArray, size=self.plWeights, pxMode=False)
        else:
            self.plot3DView.pos = self.posArray
            self.plot3DView.color = self.colorArray
            self.plot3DView.size = self.plWeights
            self.plot3DView.update()
        ## 2D Viewport
        self.plotFlatMap.setPosition(self.posArray)
        self.plotFlatMap.setColor(self.colorArray)
        self.plotFlatMap.setWeights(self.plWeights)
        self.plotFlatMap.update()

        if self.parameters['colorMask'] == 'charge':
            variable = self.CHARGE
        else:
            variable = self.TIME
        self.figCanvas.setData(variable)

    def drawColors(self):
        '''
        Only update colors, not positions or sizes
        '''
        self.colorize()
        self.plot3DView.color = self.colorArray
        self.plot3DView.update()
        self.plotFlatMap.setColor(self.colorArray)
        self.plotFlatMap.update()

    def colorize(self):
        # choose color mask, charge for now
        if self.parameters['colorMask'] == 'charge':
            variable = self.CHARGE
        else:
            variable = self.TIME
        #variable = self.TIME
        true_min = 0.0
        #min_var = max(true_min, min(variable))
        #max_var = max(variable)
        ## Override
        min_var = true_min
        max_var = self.parameters["histXMax"]
        if self.args.onlyHits:
            null_color = [1,1,1,0.0]
        else:
            null_color = [1,1,1,0.25]
        var_range = max_var - min_var
        varNorm = (variable-min_var)*1/var_range
        self.colorArray = self.parameters['colorMap'](varNorm)
        self.colorArray[variable<true_min] = null_color
        ## Invisible hack
        if self.args.invisible:
            self.colorArray *= 0

def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('ratfile', type=str, help=('rat root file'))
    parser.add_argument('--debug', action='store_true', 
            help='Turn on debug print statements')
    parser.add_argument('--tracking', action='store_true',
            help='ROOT files only. If storeTracking was used during simulation,\
            then the particle tracks will be drawn.')
    parser.add_argument('--invisible', action='store_true',
            help='This is a hack, remove eventually')
    parser.add_argument('--onlyHits', action='store_true',
            help='Show only hit pmts')
    parser.add_argument('--stream', action='store_true',
            help='Hack to test streaming capabilities')
    return parser.parse_args()

if __name__ == '__main__':
    signal.signal(signal.SIGINT, lambda *args: QtGui.QApplication.quit())
    args = get_args()
    def dprint(*argmnt):
        if args.debug:
            print(*argmnt)
    app = QtGui.QApplication([])
    guit = MainWindow(args)

    # This loops through events, potentially a way to update a stream
    if args.stream:
        start_time = time.time()
        def handler():
            eid = int(guit.event.text())
            if eid>80:
                timer.stop()
                print('Frequency:', (eid+1)/(time.time()-start_time) )
                guit.close()
            guit.rightEvent()
        timer = QtCore.QTimer()
        timer.timeout.connect(handler)
        timer.start(1)

    sys.exit(app.exec_())
